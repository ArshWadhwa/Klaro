<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle" />
              <option name="originalContent" value="plugins {&#10;    id 'java'&#10;    id &quot;org.flywaydb.flyway&quot; version &quot;7.3.1&quot;&#10;    id 'org.springframework.boot' version '3.3.3'&#10;    id 'io.spring.dependency-management' version '1.1.6'&#10;    id 'application'&#10;}&#10;&#10;String dbName = System.getenv(&quot;DB_NAME&quot;) != null ? System.getenv(&quot;DB_NAME&quot;) : &quot;klaro&quot;;&#10;String username = System.getenv(&quot;DB_USER&quot;) != null ? System.getenv(&quot;DB_USER&quot;) : &quot;postgres&quot;;&#10;String password = System.getenv(&quot;DB_PASSWORD&quot;) != null ? System.getenv(&quot;DB_PASSWORD&quot;) : &quot;postgres&quot;;&#10;&#10;group = 'org.example'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;flyway {&#10;    url = &quot;jdbc:postgresql://localhost:5432/&quot;+dbName&#10;    user = username&#10;    password = password&#10;    locations = [&quot;filesystem:${project.projectDir}/src/main/resources/migration&quot;]&#10;    baselineVersion = &quot;0&quot;&#10;    baselineOnMigrate = true&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'&#10;    implementation 'com.squareup.okhttp3:okhttp:4.9.3'&#10;    implementation 'org.springframework.boot:spring-boot-starter-validation'&#10;    // Updated Jackson dependencies to match Spring Boot 3.3.3&#10;    implementation 'com.fasterxml.jackson.core:jackson-databind:2.16.1'&#10;    implementation 'com.fasterxml.jackson.core:jackson-core:2.16.1'&#10;    implementation 'com.fasterxml.jackson.core:jackson-annotations:2.16.1'&#10;&#10;    implementation 'org.springframework.boot:spring-boot-starter-web'&#10;    implementation('org.springframework.boot:spring-boot-starter-data-jpa')&#10;    implementation 'org.postgresql:postgresql:42.7.2'&#10;    compileOnly 'org.projectlombok:lombok:1.18.30'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.30'&#10;    implementation &quot;org.springframework.boot:spring-boot-starter-log4j2&quot;&#10;    // Spring Security&#10;    implementation 'org.springframework.boot:spring-boot-starter-security'&#10;    // Spring Validation&#10;    implementation 'org.springframework.boot:spring-boot-starter-validation'&#10;&#10;    // Flyway for database migrations&#10;    implementation 'org.flywaydb:flyway-core'&#10;    implementation 'org.flywaydb:flyway-core:10.0.1'&#10;    implementation 'org.flywaydb:flyway-database-postgresql:10.0.1'&#10;&#10;//    // thymeleaf&#10;//    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'&#10;&#10;    // JWT (jjwt)&#10;    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'&#10;    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'&#10;    runtimeOnly('io.jsonwebtoken:jjwt-jackson:0.11.5') // for JSON serialization&#10;&#10;    // Validation&#10;    implementation 'jakarta.validation:jakarta.validation-api:3.0.2'&#10;}&#10;&#10;configurations {&#10;    all*.exclude module : 'spring-boot-starter-logging'&#10;}&#10;&#10;task migrateCollab(type: org.flywaydb.gradle.task.FlywayMigrateTask) {&#10;    url = &quot;jdbc:postgresql://localhost:5432/&quot;+dbName&#10;    user = username&#10;    password = password&#10;    locations = [&quot;filesystem:${project.projectDir}/src/main/resources/migration&quot;]&#10;    baselineVersion = &quot;0&quot;&#10;    baselineOnMigrate = true&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;//To run the class name from command line using gradle run&#10;application {&#10;    mainClass = 'org.example.Main'&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    id 'java'&#10;    id &quot;org.flywaydb.flyway&quot; version &quot;7.3.1&quot;&#10;    id 'org.springframework.boot' version '3.3.3'&#10;    id 'io.spring.dependency-management' version '1.1.6'&#10;    id 'application'&#10;}&#10;&#10;String dbName = System.getenv(&quot;DB_NAME&quot;) != null ? System.getenv(&quot;DB_NAME&quot;) : &quot;klaro&quot;;&#10;String username = System.getenv(&quot;DB_USER&quot;) != null ? System.getenv(&quot;DB_USER&quot;) : &quot;postgres&quot;;&#10;String password = System.getenv(&quot;DB_PASSWORD&quot;) != null ? System.getenv(&quot;DB_PASSWORD&quot;) : &quot;postgres&quot;;&#10;&#10;group = 'org.example'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;flyway {&#10;    url = &quot;jdbc:postgresql://localhost:5432/&quot;+dbName&#10;    user = username&#10;    password = password&#10;    locations = [&quot;filesystem:${project.projectDir}/src/main/resources/migration&quot;]&#10;    baselineVersion = &quot;0&quot;&#10;    baselineOnMigrate = true&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'&#10;    implementation 'com.squareup.okhttp3:okhttp:4.9.3'&#10;    implementation 'org.springframework.boot:spring-boot-starter-validation'&#10;    // Updated Jackson dependencies to match Spring Boot 3.3.3&#10;    implementation 'com.fasterxml.jackson.core:jackson-databind:2.16.1'&#10;    implementation 'com.fasterxml.jackson.core:jackson-core:2.16.1'&#10;    implementation 'com.fasterxml.jackson.core:jackson-annotations:2.16.1'&#10;&#10;    implementation 'org.springframework.boot:spring-boot-starter-web'&#10;    implementation('org.springframework.boot:spring-boot-starter-data-jpa')&#10;    implementation 'org.postgresql:postgresql:42.7.2'&#10;    &#10;    // WebSocket support&#10;    implementation 'org.springframework.boot:spring-boot-starter-websocket'&#10;    &#10;    compileOnly 'org.projectlombok:lombok:1.18.30'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.30'&#10;    implementation &quot;org.springframework.boot:spring-boot-starter-log4j2&quot;&#10;    // Spring Security&#10;    implementation 'org.springframework.boot:spring-boot-starter-security'&#10;    // Spring Validation&#10;    implementation 'org.springframework.boot:spring-boot-starter-validation'&#10;&#10;    // Flyway for database migrations&#10;    implementation 'org.flywaydb:flyway-core'&#10;    implementation 'org.flywaydb:flyway-core:10.0.1'&#10;    implementation 'org.flywaydb:flyway-database-postgresql:10.0.1'&#10;&#10;//    // thymeleaf&#10;//    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'&#10;&#10;    // JWT (jjwt)&#10;    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'&#10;    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'&#10;    runtimeOnly('io.jsonwebtoken:jjwt-jackson:0.11.5') // for JSON serialization&#10;&#10;    // Validation&#10;    implementation 'jakarta.validation:jakarta.validation-api:3.0.2'&#10;}&#10;&#10;configurations {&#10;    all*.exclude module : 'spring-boot-starter-logging'&#10;}&#10;&#10;task migrateCollab(type: org.flywaydb.gradle.task.FlywayMigrateTask) {&#10;    url = &quot;jdbc:postgresql://localhost:5432/&quot;+dbName&#10;    user = username&#10;    password = password&#10;    locations = [&quot;filesystem:${project.projectDir}/src/main/resources/migration&quot;]&#10;    baselineVersion = &quot;0&quot;&#10;    baselineOnMigrate = true&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;//To run the class name from command line using gradle run&#10;application {&#10;    mainClass = 'org.example.Main'&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/config/WebSocketConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/config/WebSocketConfig.java" />
              <option name="updatedContent" value="package org.example.config;&#10;&#10;import org.example.security.JwtUtil;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.core.Ordered;&#10;import org.springframework.core.annotation.Order;&#10;import org.springframework.messaging.Message;&#10;import org.springframework.messaging.MessageChannel;&#10;import org.springframework.messaging.simp.config.ChannelRegistration;&#10;import org.springframework.messaging.simp.config.MessageBrokerRegistry;&#10;import org.springframework.messaging.simp.stomp.StompCommand;&#10;import org.springframework.messaging.simp.stomp.StompHeaderAccessor;&#10;import org.springframework.messaging.support.ChannelInterceptor;&#10;import org.springframework.messaging.support.MessageHeaderAccessor;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;&#10;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;&#10;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;&#10;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;@Configuration&#10;@EnableWebSocketMessageBroker&#10;@Order(Ordered.HIGHEST_PRECEDENCE + 99)&#10;public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {&#10;&#10;    @Autowired&#10;    private JwtUtil jwtUtil;&#10;&#10;    @Override&#10;    public void configureMessageBroker(MessageBrokerRegistry config) {&#10;        // Enable a simple in-memory broker for broadcasting messages&#10;        config.enableSimpleBroker(&quot;/topic&quot;, &quot;/queue&quot;);&#10;        // Prefix for messages from client to server&#10;        config.setApplicationDestinationPrefixes(&quot;/app&quot;);&#10;        // Prefix for user-specific messages&#10;        config.setUserDestinationPrefix(&quot;/user&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void registerStompEndpoints(StompEndpointRegistry registry) {&#10;        // Register the WebSocket endpoint that clients will connect to&#10;        registry.addEndpoint(&quot;/ws&quot;)&#10;                .setAllowedOriginPatterns(&quot;*&quot;)&#10;                .withSockJS();&#10;    }&#10;&#10;    @Override&#10;    public void configureClientInboundChannel(ChannelRegistration registration) {&#10;        registration.interceptors(new ChannelInterceptor() {&#10;            @Override&#10;            public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {&#10;                StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);&#10;                &#10;                if (StompCommand.CONNECT.equals(accessor.getCommand())) {&#10;                    // Extract JWT token from Authorization header&#10;                    List&lt;String&gt; authorization = accessor.getNativeHeader(&quot;Authorization&quot;);&#10;                    &#10;                    if (authorization != null &amp;&amp; !authorization.isEmpty()) {&#10;                        String token = authorization.get(0);&#10;                        &#10;                        if (token.startsWith(&quot;Bearer &quot;)) {&#10;                            token = token.substring(7);&#10;                        }&#10;                        &#10;                        try {&#10;                            // Validate token and extract user info&#10;                            String email = jwtUtil.extractEmail(token);&#10;                            &#10;                            if (email != null &amp;&amp; jwtUtil.validateToken(token, email)) {&#10;                                // Create authentication object&#10;                                UsernamePasswordAuthenticationToken authentication = &#10;                                    new UsernamePasswordAuthenticationToken(&#10;                                        email, &#10;                                        null, &#10;                                        Collections.singletonList(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;))&#10;                                    );&#10;                                &#10;                                accessor.setUser(authentication);&#10;                            }&#10;                        } catch (Exception e) {&#10;                            System.err.println(&quot;WebSocket authentication failed: &quot; + e.getMessage());&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                return message;&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/entity/ChatMessage.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/entity/ChatMessage.java" />
              <option name="updatedContent" value="package org.example.entity;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@Entity&#10;@Table(name = &quot;chat_messages&quot;)&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ChatMessage {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @Column(nullable = false)&#10;    private String senderEmail;&#10;&#10;    @Column(nullable = false)&#10;    private String senderName;&#10;&#10;    @Column(nullable = false)&#10;    private String recipientEmail;&#10;&#10;    @Column(nullable = false, columnDefinition = &quot;TEXT&quot;)&#10;    private String content;&#10;&#10;    @Column(name = &quot;created_at&quot;, nullable = false)&#10;    private LocalDateTime createdAt;&#10;&#10;    @Column(name = &quot;is_read&quot;, nullable = false)&#10;    private Boolean isRead = false;&#10;&#10;    // Optional: for group chat&#10;    @Column(name = &quot;group_id&quot;)&#10;    private Long groupId;&#10;&#10;    @Column(name = &quot;project_id&quot;)&#10;    private Long projectId;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(nullable = false)&#10;    private MessageType messageType = MessageType.DIRECT;&#10;&#10;    public enum MessageType {&#10;        DIRECT,      // One-to-one messages&#10;        GROUP,       // Group messages&#10;        PROJECT      // Project-related messages&#10;    }&#10;&#10;    @PrePersist&#10;    protected void onCreate() {&#10;        createdAt = LocalDateTime.now();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/repository/ChatMessageRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/repository/ChatMessageRepository.java" />
              <option name="updatedContent" value="package org.example.repository;&#10;&#10;import org.example.entity.ChatMessage;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface ChatMessageRepository extends JpaRepository&lt;ChatMessage, Long&gt; {&#10;&#10;    // Get conversation between two users&#10;    @Query(&quot;SELECT m FROM ChatMessage m WHERE &quot; +&#10;           &quot;(m.senderEmail = :userEmail AND m.recipientEmail = :recipientEmail) OR &quot; +&#10;           &quot;(m.senderEmail = :recipientEmail AND m.recipientEmail = :userEmail) &quot; +&#10;           &quot;ORDER BY m.createdAt ASC&quot;)&#10;    List&lt;ChatMessage&gt; findConversationBetweenUsers(&#10;        @Param(&quot;userEmail&quot;) String userEmail, &#10;        @Param(&quot;recipientEmail&quot;) String recipientEmail&#10;    );&#10;&#10;    // Get all messages for a group&#10;    @Query(&quot;SELECT m FROM ChatMessage m WHERE m.groupId = :groupId AND m.messageType = 'GROUP' ORDER BY m.createdAt ASC&quot;)&#10;    List&lt;ChatMessage&gt; findByGroupId(@Param(&quot;groupId&quot;) Long groupId);&#10;&#10;    // Get all messages for a project&#10;    @Query(&quot;SELECT m FROM ChatMessage m WHERE m.projectId = :projectId AND m.messageType = 'PROJECT' ORDER BY m.createdAt ASC&quot;)&#10;    List&lt;ChatMessage&gt; findByProjectId(@Param(&quot;projectId&quot;) Long projectId);&#10;&#10;    // Get unread message count for a user&#10;    @Query(&quot;SELECT COUNT(m) FROM ChatMessage m WHERE m.recipientEmail = :userEmail AND m.isRead = false&quot;)&#10;    Long countUnreadMessages(@Param(&quot;userEmail&quot;) String userEmail);&#10;&#10;    // Get all unread messages for a user&#10;    @Query(&quot;SELECT m FROM ChatMessage m WHERE m.recipientEmail = :userEmail AND m.isRead = false ORDER BY m.createdAt DESC&quot;)&#10;    List&lt;ChatMessage&gt; findUnreadMessages(@Param(&quot;userEmail&quot;) String userEmail);&#10;&#10;    // Get recent conversations for a user&#10;    @Query(&quot;SELECT DISTINCT CASE &quot; +&#10;           &quot;WHEN m.senderEmail = :userEmail THEN m.recipientEmail &quot; +&#10;           &quot;ELSE m.senderEmail END &quot; +&#10;           &quot;FROM ChatMessage m WHERE m.senderEmail = :userEmail OR m.recipientEmail = :userEmail &quot; +&#10;           &quot;ORDER BY m.createdAt DESC&quot;)&#10;    List&lt;String&gt; findRecentConversations(@Param(&quot;userEmail&quot;) String userEmail);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>